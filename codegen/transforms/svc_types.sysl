CodeGenTransform:
  !view GoName(word <: string) -> string:
    word -> (:
      let splitted = if MatchString("^([A-Z]+[a-z]+|[A-Z]+|[a-z]+)$", word) then [word] else FindAllString("[a-z]+|[A-Z][a-z]+|[A-Z]+", word, -1)
      # Common initialisms https://github.com/golang/lint/blob/8f45f776aaf18cebc8d65861cc70c33c60471952/lint.go#L771
      let initialisms = ["ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP", "HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC", "SLA", "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID", "URI", "URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS"]

      let wordUpper = splitted -> <sequence of string> (w:
        let upper = ToTitle(w)
        out = if upper in initialisms then upper else Title(w)
      )
      out = Join(wordUpper flatten(.out), "")
    )

  !view GoType(t <: sysl.Type) -> string:
    t -> (:
      let IsPtr = if t.optional == true && t.type != "sequence" then "*" else ""
      let typeName = if t.type ==:
        "primitive" => if t.primitive ==:
          "DECIMAL" => "double"
          "INT" => "int64"
          "FLOAT" => "float64"
          "STRING" => "string"
          "STRING_8" => "string"
          "BOOL" => "bool"
          "DATE" => "date.Date"
          "DATETIME" => "time.Time"
        "sequence" => "[]" + GoType(t.sequence).out
        else GoName(t.type_ref).out
      out = IsPtr + typeName
    )

  !view filename(app <: sysl.App) -> string:
    app -> (:
      filename =  "types.go"
    )

  !view GoStructFields(fields <: set of Type) -> sequence of FieldDecl:
    fields -> (field:
      let fieldName = GoName(field.key).out
      identifier = fieldName
      let jsonTag = if field.value.attrs.json_tag == null then field.key else field.value.attrs.json_tag
      let fieldTag = '`json:"' + jsonTag
      Tag = if field.value.optional == true && field.value.type != "sequence" then (fieldTag + ',omitempty"`') else (fieldTag + '"`')
      Type = GoType(field.value).out
    )

  !view GoStructs(types <: set of Type) -> sequence of TopLevelDecl:
    types -> (type:
        let typeName = GoName(type.key).out
        Comment = '// ' + typeName + ' ...'
        Declaration = type -> <Declaration>(:
          StructType = type -> <StructType>(:
            StructName = typeName
            FieldDecl = GoStructFields(.value.fields)
          )
        )
    )
    
  !view GoAlias(aliases <: sequence of sysl.Types) -> sequence of TopLevelDecl:
    aliases -> (alias:
      let typeName = GoName(alias.key).out
      Comment = '// ' + typeName + ' ...'
      Declaration = alias -> <Declaration>(:
        AliasDecl = alias -> <AliasDecl>(:
          identifier = typeName
          Type = GoType(.value).out
        )
      )
    )
  
  !view varDecl(name <: string, typeName <: string) -> TopLevelDecl:
    name -> (:
      Comment = "// Reference imports to suppress unused errors"    
      Declaration = name -> <Declaration> (:
        VarDeclWithVal = name -> <VarDeclWithVal> (:
          identifier = name
          Expression = name -> <Expression>(:
            ValueExpr = typeName
          )
        )
      )
    )

  !view goFile(app <: sysl.App) -> goFile:
    app -> (:

      PackageClause = app -> <package> (:
        let pname = if .attrs.package != null then .attrs.package else app.name
        PackageName = ToLower(pname)
      )

      ImportDecl = app -> <ImportDecl>(:
        let restLib = "github.com/anz-bank/syslgen-examples/pkg/restlib"
        let spec = ["context", "fmt", "net/http", "net/url", "time", "", "github.com/rickb777/date", restLib] -> <sequence of ImportSpec> (importPath:
          Import = if importPath == "" then true else '"' + importPath + '"'
        )
        ImportSpec = spec
      )

      let unused = [varDecl("_", "time.Parse"), varDecl("_", "date.Parse")]

      Comment = "//\n//    THIS IS AUTOGENERATED BY sysl \n//\n"
      
      TopLevelDecl = unused | GoStructs(app.types) |  GoAlias(app.alias where(HasPrefix(.key, "EXTERNAL_") == false ))
    )
