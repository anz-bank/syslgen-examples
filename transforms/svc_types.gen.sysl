CodeGenTransform:
  !view IsKeyword(word <: string) -> bool:
    word -> (:
      out = word in {"break", "default","func","interface","select","case","defer","go","map","struct","chan","else","goto","package","switch","const","fallthrough","if","range","type","continue","for","import","return","var"}
    )
  !view GetGoField(word <: string) -> string:
    word -> (:
      let wordUpper = ToTitle(word)
      # Common initialisms https://github.com/golang/lint/blob/8f45f776aaf18cebc8d65861cc70c33c60471952/lint.go#L771
      out = if (wordUpper in {"ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP", "HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC", "SLA", "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID", "URI", "URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS"}) == true then wordUpper else Title(ToLower(word))
    )

  !view GoType(t <: sysl.Type) -> string:
    t -> (:
      let IsPtr = if t.optional == true then "*" else ""
      let typeName = if t.type ==:
        "primitive" => if t.primitive ==:
          "DECIMAL" => "double"
          "INT" => "int64"
          "FLOAT" => "float64"
          "STRING" => "string"
          "STRING_8" => "string"
          "BOOL" => "bool"
        "sequence" => "[]" + GoType(t.sequence).out
        else t.type_ref
      out = IsPtr + typeName
    )

  !view filename(app <: sysl.App) -> string:
    app -> (:
      filename =  "service.go"
    )

  !view GoStructFields(fields <: set of Type) -> sequence of FieldDecl:
    fields -> (field:
      let fieldName = GetGoField(field.key).out
      identifier = fieldName

      let fieldTag = '`json:"' + ToLower(fieldName)
      Tag = if field.value.optional == true then (fieldTag + ',omitempty"`') else (fieldTag + '"`')
      Type = GoType(field.value).out
    )

  !view GoStructs(types <: set of Type) -> sequence of TopLevelDecl:
    types -> (type:
        Comment = '// ' + type.key + ' ...'
        Declaration = type -> <Declaration>(:
          StructType = type -> <StructType>(:
            StructName = .key
            FieldDecl = GoStructFields(.value.fields)
          )
        )
    )

  !view GoInterfaces(unions <: set of Type) -> sequence of TopLevelDecl:
    unions -> (union:
        Comment = '// ' + union.key + ' ...'
        Declaration = union -> <Declaration>(:
          InterfaceType = union -> <InterfaceType>(:
            InterfaceName = .key
            let methodName = "Is" + .key
            MethodSpec = [methodName] -> <sequence of MethodSpec> (name:
              MethodName = name
              Signature = "" -> <Signature> (:
                Parameters = true
              )
            )
            MethodDecl = union.value.fields -> <sequence of MethodDecl> (receiverName:
              Receiver = receiverName -> <Receiver>(:
                ReceiverType = "*" + receiverName
              )
              FunctionName = methodName
              Signature = receiverName -> <Signature> (:
                Parameters = true
              )
              Block = receiverName -> <Block> (:
                out = ""
              )
            )
          )
        )
    )

  !view methodName(method <: string, urlPath <: string) -> string:
    method -> (:
      let path = Replace(urlPath, "/", "_", -1)
      let path2 = Replace(path, "{", "", -1)
      let path3 = Replace(path2, "}", "", -1)
      out = method + path3
    )

  !view clientName(name <: string) -> string:
    name -> (:
      out = Title(ToLower(name)) + "Client"
    )

  !view createOutVariable(typeName <: string) -> DeclareAndAssignStmt:
    typeName -> (:
      Statement = typeName -> <Statement> (:
        DeclareAndAssignStmt = typeName -> <DeclareAndAssignStmt> (:
          Variables = "out"
          Expression = typeName -> <Expression> (:
            NewStruct = typeName -> <NewStruct> (:
              StructName = typeName
            )
          )
        )
      )
    )

  !view formatArgs(ep <: sysl.Endpoint) -> string:
    ep -> (:
      let queryvarsFmt = ep.value.queryvars -> <string>(:
        out = .name + '=' + "%v"
      )
      queryVars = Join(queryvarsFmt flatten(.out), "&")
      let terms = ep.value.pathvars -> <out> (:
        out = "{" + .name + "}"
      )
      let terms2 = terms flatten(.out)
      let path = Split(ep.value.path, "/")
      let path2 = path -> <string> (p:
        out  = if p in terms2 then "%v" else p
      )
      out = path2 flatten(.out)
    )

  !view buildSprintfCall(ep <: sysl.Endpoint) -> string:
    ep -> (:
      let args = formatArgs(ep)
      let q = if Contains(args.queryVars, "=") then "?" + args.queryVars else ""
      formatArgs = '"%s' + Join(args.out, "/") + q + '"'
    )

  !view makeGetArgExpr(lhs <: string, rhs <: string) -> Expression:
    lhs -> (:
      Expression = lhs -> <Expression>(:
        GetArg = lhs -> <GetArg>(:
          LHS = lhs
          RHS = rhs
        )
      )
    )

  !view makeValueExpr(strValue <: string) -> Expression:
    strValue -> (:
      Expression = strValue -> <Expression>(:
        ValueExpr = strValue
      )
    )

  !view makeFunctionZero(funcName <: string) -> Expression:
    funcName -> (:
      Expression = funcName -> <Expression>(:
        FunctionCall = funcName -> <FunctionCall>(:
          FunctionName = funcName
        )
      )
    )

  !view makeFunctionOneArg(funcName <: string, arg0 <: Expression) -> Expression:
    funcName -> (:
      Expression = funcName -> <Expression>(:
        FunctionCall = funcName -> <FunctionCall>(:
          FunctionName = funcName
          FunctionArgs = funcName -> <FunctionArgs> (:
            Expression = arg0.Expression
          )
        )
      )
    )
    
  !view makeFunctionCall(funcName <: string, arg0 <: Expression, rest <: sequence of Expression) -> Expression:
    funcName -> (:
      Expression = funcName -> <Expression>(:
        FunctionCall = funcName -> <FunctionCall>(:
          FunctionName = funcName
          FunctionArgs = funcName -> <FunctionArgs> (:
            Expression = arg0.Expression
            FuncArgsRest = rest -> <FuncArgsRest> (:
              Expression = .Expression
            )
          )
        )
      )
    )
    
  !view callRestLib(ep <: string) -> DeclareAndAssignStmt:
    ep -> (:
      Statement = ep -> <Statement> (:
        ReturnStmt = ep -> <ReturnStmt> (:
          let args = buildSprintfCall(ep)
          let params = ep.value.pathvars -> <string> (:
            Expression =  makeValueExpr(.name).Expression
          )
          let qparam = ep.value.queryvars -> <string> (:
            Expression = if GoType(.).out == "string" then makeFunctionOneArg("url.QueryEscape", makeValueExpr(.name)).Expression else makeValueExpr(.name).Expression
          )

          let restArg = [makeGetArgExpr("s", "url")] | params | qparam
          let sprintfCall = makeFunctionCall("fmt.Sprintf", makeValueExpr(args.formatArgs), restArg)

          let body = ep.value.params where("body" in .attrs.patterns) -> <Expression> (:
            Expression = makeValueExpr(.name).Expression
          )
          
          let nilExpr = ep -> <Expression> (:
            Expression = makeValueExpr("nil").Expression
          )

          let body2 = if body count == 0 then [nilExpr] else body

          let restofArgs = [makeValueExpr("ctx"), makeValueExpr('"' + ep.value.method + '"'), sprintfCall] | body2 | [makeValueExpr("headers"), makeValueExpr("required") , makeValueExpr("responses")]

          Expression =  makeFunctionCall("restlib.DoHttpRequest", makeGetArgExpr("s", "client"), restofArgs).Expression
        )
      )
    )

  !view callHttpMethodWithNoQueryArgs(methodName <: string, ep <: sysl.Endpoint) -> Block:
    ep -> (:
      Statement = ep -> <Statement> (:
        DeclareAndAssignStmt = ep -> <DeclareAndAssignStmt> (:
          Variables = "resp, err"
          let args = buildSprintfCall(ep)
          let params = ep.value.pathvars -> <string> (:
            Expression =  makeValueExpr(.name).Expression
          )
          let restArg = [makeGetArgExpr("s", "url")] | params
          let sprintfCall = makeFunctionCall("fmt.Sprintf", makeValueExpr(args.formatArgs), restArg)
          Expression = makeFunctionCall("restlib.DoHttpRequest", makeGetArgExpr("s", "client"), [ makeValueExpr("ctx"), makeValueExpr('"' + methodName + '"'), sprintfCall, makeValueExpr("responses")] ).Expression
        )
      )   
    )

  !view declareReturnTypeArray(variableName <: string, typeName <: string, values <: sequence of string) -> DeclareAndAssignStmt:
    typeName -> (:
      Statement = typeName -> <Statement> (:
        DeclareAndAssignStmt = typeName -> <DeclareAndAssignStmt> (:
          Variables = variableName
          Expression = typeName -> <Expression> (:
            NewSlice = typeName -> <NewSlice> (:
              TypeName = typeName
              let v = values -> <sequence of string> (:
                out = '&' + . + '{}'
              )
              SliceValues = Join(v flatten(.out), ',')
            )
          )   
        )
      )
    )

  !view declareHeaders(variableName <: string, typeName <: string, values <: sequence of string) -> DeclareAndAssignStmt:
    typeName -> (:
      Statement = typeName -> <Statement> (:
        DeclareAndAssignStmt = typeName -> <DeclareAndAssignStmt> (:
          Variables = variableName
          Expression = typeName -> <Expression> (:
            NewSlice = typeName -> <NewSlice> (:
              TypeName = typeName
              let v = values -> <sequence of string> (:
                out = '"' + . + '"'
              )
              SliceValues = Join(v flatten(.out), ',')
            )
          )   
        )
      )
    )

  !view addToContextCall(variable <: string, methodName <: string) -> Expression:
    variable -> (:
      Statement = variable -> <Statement> (:
        AssignStmt = variable -> <AssignStmt> (:
          Variables = "ctx"
          Expression = makeFunctionCall(methodName, makeValueExpr("ctx"), [makeValueExpr(variable)]).Expression
        )
      )
    )

  !view returnOutAndErr(name <: string) -> DeclareAndAssignStmt:
    name -> (:
      Statement = name -> <Statement> (:
        ReturnStmt = name -> <ReturnStmt> (:
          PayLoad = Join(["resp", name, "err"], ",")
        )
      )   
    )

  !view HttpMethodStatments(ep <: sysl.Endpoint) -> StatementList:
    ep -> (:
      let requiredHeaders = ep.value.params where("header" in .attrs.patterns && "required" in .attrs.patterns)
      let required = declareHeaders("required", "string", requiredHeaders flatten(.attrs.name))

      # let optionalHeaders = ep.value.params where("header" in .attrs.patterns && "optional" in .attrs.patterns)
      # let optional = declareHeaders("optional", "string", optionalHeaders flatten(.attrs.name))

      let responses = declareReturnTypeArray("responses", "interface{}", Split(ep.value.ret.payload, ', '))

      StatementList = [required, responses, callRestLib(ep)]
    )

  !view ClientMethods(appName <: string, eps <: set of sysl.Endpoints) -> sequence of MethodSpec:
    eps -> (ep:
      let funcName = methodName(ep.value.method, ep.value.path).out
      Comment = '// ' + funcName + ' ...'
      MethodDecl = ep -> <MethodDecl>(:
        Receiver = ep -> <Receiver>(:
          ReceiverType = 's *' + clientName(appName).out
        )
        FunctionName = funcName
        Signature = methodSignature(ep)
        Block = HttpMethodStatments(ep)
      )
    )

  !view methodSignature(ep <: sysl.Endpoint) -> Signature:
    ep -> (:
      Parameters = ep -> <Parameters>(:
        ParameterList = ep -> <ParameterList>(:
          ParameterDecl = ep -> <ParameterDecl>(:
            Identifier = "ctx"
            TypeName = "context.Context"
          )

          let httpHeader = ep -> <ParameterDecl>(:
            ParameterDecl = ep -> <ParameterDecl>(:
              Identifier = "headers"
              TypeName = "map[string]string"
            )
          )

          let paramList = ep.value.params where ("body" in .attrs.patterns ) | ep.value.pathvars | ep.value.queryvars
          let paramTemp  = paramList -> <sequence of ParameterDeclC>(p:
            ParameterDecl = p -> <ParameterDecl>(:
              Identifier = p.name
              TypeName = GoType(p).out
            )
          )
          ParameterDeclC = [httpHeader] | paramTemp
        )
      )
      Result = ep -> <Result> (:
        ReturnTypes = ep -> <ReturnTypes> (:
          ResultTypeList = ["*restlib.HttpResult", "error"] -> <ResultTypeList>(name:
            TypeName = name
          )
        )
      )
    )


  !view GoMethods(eps <: set of sysl.Endpoints) -> sequence of MethodSpec:
    eps -> (ep:
      MethodName = methodName(ep.value.method, ep.value.path).out
      Signature = methodSignature(ep)
    )

  !view GoAlias(aliases <: set of sysl.Types) -> sequence of Declaration:
    aliases -> (alias:
      Comment = '// ' + alias.key + ' ...'
      Declaration = alias -> <Declaration>(:
        AliasDecl = alias -> <AliasDecl>(:
          identifier = .key
          Type = GoType(.value).out
        )
      )
    )

  !view goFile(app <: sysl.App) -> string:
    app -> (:

      PackageClause = .name -> <package> (name:
        PackageName = "main"
      )

      ImportDecl = app -> <ImportDecl>(:
        ImportSpec = ["../lib", "context", "fmt", "net/http", "net/url"] -> <ImportSpec> (importPath:
          Import = '"' + importPath + '"'
        )
      )

      let svcInterface = [.name] -> <TopLevelDecl> (name:
        Comment = '// ' + name + ' ...'
        Declaration = name -> <Declaration>(:
          InterfaceType = name -> <InterfaceType>(:
            InterfaceName = name
            MethodSpec =  GoMethods(app.endpoints)
          )
        )
      )
      
      let clientStruct = [.name] -> <TopLevelDecl> (name:
        Comment = '// ' + clientName(name).out + ' ...'
        Declaration = name -> <Declaration>(:
          StructType = name -> <StructType>(:
            StructName = clientName(name).out

            let urlField = name -> <FieldDecl>(:
              identifier = "url"
              Type = "string"
            )

            let client = name -> <FieldDecl>(:
              identifier = "client"
              Type = "*http.Client"
            )

            FieldDecl = [client, urlField]
          )
        )
      )

      let makeClient = [.name] -> <TopLevelDecl> (name:
        Comment = '// ' + "Make" + clientName(name).out + ' ...'
        FunctionDecl = name -> <FunctionDecl>(:
          FunctionName = "Make" + clientName(name).out
          Signature = name -> <Signature> (:
            Parameters = name -> <Parameters>(:
              ParameterList = name -> <ParameterList>(:

                let urlField = name -> <ParameterDecl>(:
                    Identifier = "url"
                    TypeName = "string"
                )

                ParameterDecl = name -> <ParameterDecl>(:
                  Identifier = "client"
                  TypeName = "*http.Client"
                )
                ParameterDeclC = [urlField] -> <ParameterDeclC>(p:
                  ParameterDecl = p -> <ParameterDecl>(:
                    Identifier = p.Identifier
                    TypeName = p.TypeName
                  )
                )
              )
            )

            Result = name -> <Result> (:
              TypeName = "*"+clientName(name).out
            )
          )
          Block = name -> <Block>(item:
            StatementList = [item] -> <StatementList>(item:
              Statement = item -> <Statement> (:
                ReturnStmt = item -> <ReturnStmt> (:
                  PayLoad = '&' + clientName(name).out + '{client, url}'
                )
              )
            )
          )
        )
      )
      TopLevelDecl = GoStructs(app.types) | GoAlias(app.alias) | GoInterfaces(app.union) | svcInterface | clientStruct |  makeClient  |  ClientMethods(.name, app.endpoints)
    )
