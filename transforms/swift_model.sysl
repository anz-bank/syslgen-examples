SwiftModel:  
  !view filename(app <: sysl.App) -> string:
    app -> (:
      filename =  "model.swift"
    )

  !view swiftFile(app <: sysl.App) -> string:
    app -> (:
      let imports = Imports(["Alamofire", "Foundation"])
      let client = Client(app)
      Statement = imports | Structs(app.types) | Alias(app.alias) | [client]
    )

  !view Imports(names <: sequence of string) -> sequence of Statement:
    names -> (name:
      Declaration = name -> <Declaration> (:
        ImportDecl = name -> <ImportDecl>(:
          ImportPath = name
        )
      )
    )

  !view SwiftType(t <: sysl.Type) -> string:
    t -> (:
      let optional = if t.optional == true && t.type != "sequence" then "?" else ""
      let typeName = if t.type ==:
        "primitive" => if t.primitive ==:
          "DECIMAL" => "Decimal"
          "INT" => "Int"
          "FLOAT" => "Float"
          "STRING" => "String"
          "STRING_8" => "String"
          "BOOL" => "Bool"
          "DATE" => "Date"
          "DATETIME" => "Date"
        "sequence" => "[" + SwiftType(t.sequence).out + "]"
        else if HasPrefix(t.type_ref, "EXTERNAL_") == true then SwiftName(Trim(t.type_ref, "EXTERNAL_")).out else SwiftName(t.type_ref).out
      out = typeName + optional
    )

  !view StructFields(fields <: set of Type) -> sequence of StructMember:
    fields -> (field:
      Declaration = VarDecl(field.key, SwiftType(field.value).out, null)
    )
  
  !view EnumCase(fields <: set of Type) -> sequence of EnumMember:
    fields -> (field:
      EnumCase = field -> <EnumCase> (:
        let jsonTag = if .value.attrs.json_tag == null then .key else .value.attrs.json_tag
        EnumCaseName = .key
        EnumValueAssignment = jsonTag -> <EnumValueAssignment>(value:
          EnumRawValue = '"' + value + '"'
        )
      )
    )

  !view Alias(aliases <: sequence of sysl.Types) -> sequence of Statement:
    aliases -> (alias:
      Declaration = alias -> <Declaration>(:
        let typeName = SwiftName(alias.key).out

        TypeAlias = alias -> <TypeAlias>(:
          TypeName = typeName
          ExistingType = SwiftType(.value).out
        )
      )
    )

  !view Structs(types <: set of Type) -> sequence of Statement:
    types -> (type:
      Declaration = type -> <Declaration> (:
        StructDecl = type -> <StructDecl>(:
          StructName = type.key
          Body = type -> <Body>(:
            let members = StructFields(.value.fields)
            let codingKey = type -> <Member> (:
              Declaration= type -> <Declaration> (:
                EnumDecl = type -> <EnumDecl> (:
                  EnumName = 'CodingKeys'
                  Inherit = type -> <Inherit> (:
                    IdentifierList = IdentList('String', ['CodingKey'])
                  )
                  EnumBlock = type -> <EnumBlock> (:
                    EnumMember = EnumCase(.value.fields)
                  )
                )
              )
            )
            Member = members | [codingKey]
          )
          Inherit = type -> <Inherit> (:
            IdentifierList = IdentListOne('Codable')
          )

        )
      )
    )

  !view VarDecl(name <: string, typeName <: string, modifier <: string) -> Declaration:
    name -> (:
      VarDecl = name -> <VarDecl>(:
        Identifier = name
        TypeName = typeName
        AccessModifier = modifier
      )
    )

  !view SwiftName(word <: string) -> string:
    word -> (:
      let splitted = if MatchString("^([A-Z]+[a-z]+|[A-Z]+|[a-z]+)$", word) then [word] else FindAllString("[a-z]+|[A-Z][a-z]+|[A-Z]+", word, -1)

      let wordUpper = splitted -> <sequence of string> (w:
        out = Title(w)
      )
      out = Join(wordUpper flatten(.out), "")
    )


  !view methodName(method <: string, urlPath <: string) -> string:
    method -> (:
      let path = Replace(urlPath, "/", "_", -1)
      let path2 = Replace(path, "{", "", -1)
      let path3 = Replace(path2, "}", "", -1)
      out = SwiftName(Title(ToLower(method)) + path3).out
    )

  !view varName(name <: string) -> string:
    name -> (:
      out = ToLower(Join(Split(name, "_"), ""))
    )

  !view methodParams(params <: sysl.Params) -> sequence of ParameterC:
    params -> (param:
      Parameter = makeParam(varName(param.name).out, SwiftType(param).out)
    )


  !view queryVarCall(ep <: sysl.Endpoint) -> sequence of Statement:
    ep.value.queryvars -> (q:
      FunctionCall = q -> <FunctionCall>(:
        FunctionName = "URLQueryItem"
        IdentifierList = IdentList('"' + q.name + '"', [varName(q.name).out])
      )
    )

  !view queryVars(ep <: sysl.Endpoint) -> Statement:
    ep -> (:
      Expression = ep -> <ArrayLiteral>(:
        ArrayLiteral = ep -> <Expression>(:
          ExpressionList = queryVarCall(ep)
        )
      )
    )

  !view paramValue(p <: sysl.Param) -> string:
    p -> (:
      let unwrap = if p.optional == true then '!' else ''
      let varName = varName(p.name).out
      out = if p.type ==:
        "primitive" => if p.primitive == "STRING" then  varName + unwrap else '"\(' + varName + unwrap + ')"'
        else '"\(' + varName + unwrap + ')"'
    )

  !view addOptionalQueryVars(q <: sysl.Param) -> Expression:
    q -> (:
      IfElseExpr = q -> <IfElseExpr>(:
        let argName = varName(q.name).out
        Expression =  makePredExpr(makeIdent(argName), "!=", makeIdent("nil"))
        StmtBlock = q -> <StmtBlock> (:
          let argList = IdentList( "name:" + '"' + q.name + '"', [ "value:" + paramValue(q).out])
          let p = DeclareLetExpr("p", makeFuncCall("URLQueryItem", argList))
          let stmtAdd = makeFunctionStmt(makeFuncCallOneExpr("queryItems.append", "p"))
          Statement = [p, stmtAdd]
        )
      )
    )

  !view addRequiredQueryVars(q <: sysl.Param) -> Expression:
    q -> (:
      FunctionCall = q -> <FunctionCall>(:
        let argName = varName(q.name).out
        let argList = IdentList( "name:" + '"' + q.name + '"', [ "value:" + paramValue(q).out])

        FunctionName = "queryItems.append"
        IdentifierList = q -> <IdentifierList>(:
          Expression = makeFuncCall("URLQueryItem", argList)
        )
        NewLine = "\n"
      )
    )

  !view buildQueryItems(ep <: sysl.Endpoint) -> sequence of Expression:
    ep.value.queryvars -> (q:
      Expression = if q.optional ==:
        true => addOptionalQueryVars(q)
        else addRequiredQueryVars(q)
    )
  
  !view callClosure(ep <: sysl.Endpoint, matchIt <: string) -> Statement:
    ep -> (:
      let splitPayload = Split(ToLower(ep.value.ret.payload), ",")
      let nils = splitPayload -> <string> (item:
        out = if item == matchIt then matchIt else "nil"
      )
      let payload = nils flatten(.out)
      let rest = IdentList('response', payload)
      out = makeFunctionStmt(makeFuncCall('closure', rest))
    )

  !view responseJsonDoBlock(ep <: sysl.Endpoint) -> Statement:
    Split(ep.value.ret.payload, ",") -> (ret:
      Expression = ret -> <Expression> (:
        IfElseExpr = ret -> <IfElseExpr>(ret:
          let returnVar = ToLower(ret)
          Expression = DeclareLetExpr(returnVar, tryFuncCall('try?', makeFuncCallTwoExpr("decoder.decode", ret + ".self", "from: json"))).Expression
          StmtBlock = ret -> <StmtBlock>(:
            let callClosure = callClosure(ep, returnVar).out
            let returnStmt = returnStmt(makeIdent(""))
            Statement = [callClosure]| [returnStmt]
          )
        )
      )
    )
  
  !view responseJson(ep <: sysl.Endpoint) -> Statement:
    ep -> (:
      Expression = ep -> <Expression> (:
        FunctionCall = ep -> <FunctionCall>(:
          FunctionName = 'req.responseJSON'
          IdentifierList = ep -> <IdentifierList>(:
            identifier = 'queue: queue'
          )
          ClosureExpr = ep -> <ClosureExpr> (:
            ClosureSignature = ep -> <ClosureSignature>(:
              IdentifierList = IdentListOne('response')
            )
            let ifelse = ep -> <Statement> (:
              Expression = ep -> <Expression> (:
                IfElseExpr = ep -> <IfElseExpr>(:
                  Expression = DeclareLetExpr('json', makeIdent('response.data')).Expression
                  StmtBlock = ep -> <StmtBlock>(:
                      let decoder = DeclareLetExpr("decoder", makeFuncCallZeroExpr("JSONDecoder"))
                      let doblock = responseJsonDoBlock(ep)
                      Statement = [decoder] | doblock
                  )
                )
              )
            )
            let callClosure = callClosure(ep, "nil").out
            Statement = [ifelse, callClosure]
          )
        )
      )
    )

  !view clientMethodStatements(ep <: sysl.Endpoint) -> StmtBlock:
    ep -> (:
      let needQueryVars = ep.value.queryvars where(.optional == true) count > 0
      let urlComponent = DeclareVarExpr("urlComponent", makeFuncCallZeroExpr("URLComponents"))
      let queryItems = DeclareVarExpr("queryItems", makeFuncCallZeroExpr("[URLQueryItem]"))
      let scheme = AssignVarExpr("urlComponent.scheme", makeIdent('self.scheme'))
      let host = AssignVarExpr("urlComponent.host", makeIdent('self.hostName'))
      let assignQueryItems = AssignVarExpr("urlComponent.queryItems", makeIdent('queryItems'))
      let path = AssignVarExpr("urlComponent.path", makeIdent(buildURL(ep).out))
      let request = DeclareLetExpr("req", makeFuncCallTwoExpr('Alamofire.request', "urlComponent.url!", 'headers:headers'))
      let queryExpr= buildQueryItems(ep)
      let responseJson = responseJson(ep)
      let preStatements = if needQueryVars == true then [urlComponent, queryItems, scheme, host, path] else [urlComponent, scheme, host, path]
      let postStatements = if needQueryVars == true then [assignQueryItems, request, responseJson] else [request, responseJson]
      Statement = preStatements | queryExpr | postStatements
    )
  
  !view buildURL(ep <: sysl.Endpoint) -> string:
    ep -> (:
      let p1 = Replace(ep.value.path, '{', '\(', -1)
      let p2 = Replace(p1, '}', ')', -1)
      out = '"' + p2 + '"'
    )
  
  !view clientMethods(eps <: sysl.Endpoint) -> sequence of Member:
    eps -> (ep:
      Declaration = ep -> <Declaration>(:
        FuncDecl = ep -> <FuncDecl>(:
          FuncName = methodName(ep.value.method, ep.value.path).out
          Parameters = ep -> <Parameters>(:
            Parameter = ep -> <Parameter>(:
              Label = "_"
              ParamName= "headers"
              TypeName = "[String: String]"
            )
            let closure = ep -> <Parameters>(:
              Parameter = ep -> <Parameter>(:
                let p = Split(ep.value.ret.payload, ',') -> <sequence of string>(item:
                  out = item + "?"
                )
                let payload = Join(p flatten(.out), ",")
                
                Label = "_"
                ParamName= "closure"
                TypeName = "@escaping (DataResponse<Any>, " + payload + ")->Void"
              )
            )
            let paramList = ep.value.pathvars | ep.value.queryvars
            ParameterC = methodParams(paramList) | [closure]
          )
          StmtBlock = clientMethodStatements(ep) 
        )
      )
    )
  
  !view clientBody(app <: sysl.App) -> Body:
    app -> (:
      let queue = variable('queue', 'DispatchQueue', 'private')
      let scheme = variable('scheme', 'String', 'private')
      let hostname = variable('hostName', 'String', 'private')
      let initParameters = app -> <Parameters>(:
        let p1 = makeParam('scheme', 'String')
        let p2 = makeParam('hostname', 'String')
        Parameter =makeParam('queue', 'DispatchQueue')
        ParameterC = [p1, p2] -> <ParameterC>(p:
          Parameter = p
        )
      )
      let block = app -> <Statement>(:
        let queue1 = AssignVarExpr('self.queue', makeIdent('queue'))
        let sc = AssignVarExpr('self.scheme', makeIdent('scheme'))
        let host = AssignVarExpr('self.hostName', makeIdent('hostname'))
        Statement = [queue1, sc, host]
      )
      let initFunc = declareFunc('init', 'public', initParameters, block)

      Member = [queue, scheme, hostname, initFunc] | clientMethods(app.endpoints)
    )

  !view Client(app <: sysl.App) -> Statement:
    app -> (:
      Declaration = app -> <Declaration>(:
        ClassDecl = app -> <ClassDecl>(:
          ClassName='Client'
          Body = clientBody(app) 
        )
      )
    )

  !view makePredExpr(lhs <: Expression, op <: string, rhs <: Expression) -> Expression:
    lhs -> (:
      PredicateExpr = lhs -> <PredicateExpr>(:
        Lhs = lhs -> <Expression>(:
          Expression = lhs
        )
        CompareOp = op
        Rhs = rhs -> <Expression>(:
          Expression = rhs
        )
      )
    )

  !view makeIdent(name <: string) -> Expression:
    name -> (:
      Identifier = name
    )

  !view AssignVarExpr(name <: string, e <: Expression) -> Statement:
    name -> (:
      Expression = name -> <Expression>(:
        AssignVarExpr = name -> <AssignVarExpr>(:
          VarName = name
          Expression = e
        )
      )
    )

  !view DeclareVarExpr(name <: string, e <: Expression) -> Statement:
    name -> (:
      Expression = name -> <Expression>(:
        DeclareVarExpr = name -> <DeclareVarExpr>(:
          VarName = name
          Expression = e
        )
      )
    )

  !view DeclareLetExpr(name <: string, e <: Expression) -> Statement:
    name -> (:
      Expression = name -> <Expression>(:
        Try = try
        DeclareLetExpr = name -> <DeclareLetExpr>(:
          VarName = name
          Expression = e
        )
      )
    )

  !view tryFuncCall(tryExpr <: string, func <: FunctionCall) -> Expression:
    tryExpr -> (:
      Try = tryExpr
      FunctionCall = func.FunctionCall
    )

  !view makeFuncCall(name <: string, identList <: IdentifierList) -> Expression:
    name -> (:
      FunctionCall = name -> <FunctionCall>(:
        FunctionName = name
        IdentifierList = identList
      )
    )

  !view makeFuncCallOneExpr(name <: string, arg <: string) -> Expression:
    name -> (:
      FunctionCall = name -> <FunctionCall>(:
        FunctionName = name
        IdentifierList = IdentListOne(arg)
      )
    )

  !view makeFuncCallZeroExpr(name <: string) -> Expression:
    name -> (:
      FunctionCall = name -> <FunctionCall>(:
        FunctionName = name
      )
    )

  !view makeFunctionStmt(func <: FunctionCall) -> Statement:
    func -> (:
      Expression = func
    )
  
  !view makeStmt(decl <: Declaration) -> Statement:
    decl -> (:
      Declaration = decl
    )
  
  !view makeParam(name <: string, typeName <: string) -> Parameter:
    name -> (:
      Label = "_"
      ParamName = name
      TypeName = typeName
    )

  !view IdentListOne(firstItem <: string) -> IdentifierList:
    firstItem -> (:
      identifier = firstItem
    )

  !view IdentList(firstItem <: string, rest <: sequence of string) -> IdentifierList:
    firstItem -> (:
      identifier = firstItem
      IdentifierListC = rest -> <IdentifierListC> (item:
        identifier = item
      )
    )

  !view declareFunc(name <: string, modifier <: string, params <: Parameters, stmts <: StmtBlock) -> Member:
    name -> (:
      Declaration = name -> <Declaration>(:
        InitFuncDecl = name -> <InitFuncDecl>(:
          AccessModifier = modifier
          FuncName = name
          Parameters = params
          StmtBlock = stmts
        )
      )
    )

  !view makeFuncCallTwoExpr(name <: string, arg1 <: string, arg2 <: string) -> Expression:
    name -> (:
      FunctionCall = name -> <FunctionCall>(:
        FunctionName = name
        IdentifierList = IdentList(arg1, [arg2])
      )
    )

  !view variable(name <: string, typeName <: string, modifier <: string) -> Member:
    name -> (:
      Declaration = VarDecl(name, typeName, modifier)
    )

  !view returnStmt(e <: Expression) -> Statement:
    e -> (:
      ReturnStmt = e -> <ReturnStmt>(:
        Expression = e
      )
    )
